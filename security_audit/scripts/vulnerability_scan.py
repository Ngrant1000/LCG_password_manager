#!/usr/bin/env python3
"""
LCG Password Manager - Vulnerability Scanner

This script scans the codebase for common security vulnerabilities and generates a report.
"""

import os
import sys
import re
import json
import argparse
import datetime
from pathlib import Path
from typing import Dict, List, Any, Tuple, Set, Optional

# Add the project root to the Python path
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

class VulnerabilityScanner:
    """Scanner for common security vulnerabilities in the codebase."""
    
    def __init__(self, output_dir: Optional[str] = None):
        """Initialize the vulnerability scanner with an optional output directory."""
        self.output_dir = Path(output_dir) if output_dir else Path(__file__).parent.parent / "reports"
        self.output_dir.mkdir(exist_ok=True)
        self.results = {
            "timestamp": datetime.datetime.now().isoformat(),
            "version": "1.0.0",
            "vulnerabilities": []
        }
        
        # Define common vulnerability patterns
        self.vulnerability_patterns = {
            "hardcoded_secrets": [
                # Exclude variable assignments that use secure methods
                (r'(?<!secrets\.)(?<!urandom\()(?<!bytes\()password\s*=\s*["\'][^"\']+["\']', "Hardcoded password detected"),
                (r'(?<!secrets\.)(?<!urandom\()(?<!bytes\()api_key\s*=\s*["\'][^"\']+["\']', "Hardcoded API key detected"),
                (r'(?<!secrets\.)(?<!urandom\()(?<!bytes\()secret\s*=\s*["\'][^"\']+["\']', "Hardcoded secret detected"),
                # Exclude common non-secret keys
                (r'(?<!public_)(?<!private_)key\s*=\s*["\'][^"\']{8,}["\']', "Hardcoded key detected"),
                (r'(?<!session_)(?<!access_)token\s*=\s*["\'][^"\']{8,}["\']', "Hardcoded token detected"),
            ],
            "insecure_random": [
                # Only flag when not used for non-security purposes
                (r'(?<!test_)(?<!mock_)random\.random\(\)', "Insecure random number generation detected"),
                (r'(?<!test_)(?<!mock_)random\.randint\(', "Insecure random number generation detected"),
                (r'(?<!test_)(?<!mock_)random\.choice\(', "Insecure random number generation detected"),
                (r'(?<!test_)(?<!mock_)random\.shuffle\(', "Insecure random number generation detected"),
            ],
            "weak_crypto": [
                # More specific patterns for crypto usage
                (r'hashlib\.md5\(', "Weak cryptographic hash function (MD5) detected"),
                (r'hashlib\.sha1\(', "Weak cryptographic hash function (SHA1) detected"),
                (r'Crypto\.Cipher\.DES', "Weak encryption algorithm (DES) detected"),
                (r'Cryptodome\.Cipher\.DES', "Weak encryption algorithm (DES) detected"),
                (r'Crypto\.Cipher\.ARC4', "Weak encryption algorithm (RC4) detected"),
                (r'Cryptodome\.Cipher\.ARC4', "Weak encryption algorithm (RC4) detected"),
                (r'mode=MODE_ECB', "Insecure encryption mode (ECB) detected"),
            ],
            "sql_injection": [
                # More specific SQL injection patterns
                (r'execute\s*\(\s*f["\'].*?{.*?}.*?["\']', "Potential SQL injection vulnerability detected"),
                (r'execute\s*\(\s*["\'][^"\']*?\%[^"\']*?["\'].*?%', "Potential SQL injection vulnerability detected"),
                (r'executemany\s*\(\s*f["\'].*?{.*?}.*?["\']', "Potential SQL injection vulnerability detected"),
            ],
            "command_injection": [
                # More specific command injection patterns
                (r'os\.system\s*\(\s*f["\'].*?{.*?}.*?["\']', "Potential command injection vulnerability detected"),
                (r'subprocess\.(?:call|Popen|run)\s*\(\s*f["\'].*?{.*?}.*?["\']', "Potential command injection vulnerability detected"),
                (r'subprocess\.(?:call|Popen|run)\s*\(\s*["\'][^"\']*?\+.*?\)', "Potential command injection vulnerability detected"),
            ],
            "path_traversal": [
                # More specific path traversal patterns
                (r'open\s*\(\s*(?:os\.path\.join\s*\([^)]*?\.\.[^)]*?\)|f["\'][^"\']*?\.\..*?["\'])', "Potential path traversal vulnerability detected"),
                (r'(?<!safe_)open\s*\(\s*["\'][^"\']*?\.\..*?["\']', "Potential path traversal vulnerability detected"),
            ],
            "insecure_deserialization": [
                # More specific deserialization patterns
                (r'(?<!safe_)(?<!trusted_)pickle\.(?:loads|load)\s*\(', "Insecure deserialization (pickle) detected"),
                (r'(?<!safe_)(?<!trusted_)yaml\.(?:load|unsafe_load)\s*\(', "Insecure deserialization (YAML) detected"),
                (r'(?<!safe_)(?<!trusted_)marshal\.loads\s*\(', "Insecure deserialization (marshal) detected"),
            ],
            "debug_code": [
                # More specific debug code patterns
                (r'(?<!def\s)print\s*\(\s*["\'][^"\']*?(?:password|secret|key|token)[^"\']*?["\']', "Debug code exposing sensitive information detected"),
                (r'logging\.(?:debug|info|warning|error|critical)\s*\(\s*["\'][^"\']*?(?:password|secret|key|token)[^"\']*?["\']', "Debug code exposing sensitive information detected"),
            ],
            "insecure_defaults": [
                # More specific insecure defaults patterns
                (r'chmod\s*\(\s*["\']?\s*(?:0o777|0777|777)\s*["\']?\s*\)', "Insecure default permissions detected"),
                (r'os\.chmod\s*\(\s*["\']?\s*(?:0o777|0777|777)\s*["\']?\s*\)', "Insecure default permissions detected"),
                (r'permissions\s*=\s*(?:0o777|0777|777)', "Insecure default permissions detected"),
            ],
            "missing_validation": [
                # More specific input validation patterns
                (r'(?<!validate_)input\s*\(\s*[^)]*?\)', "Missing input validation detected"),
                (r'(?<!validate_)raw_input\s*\(\s*[^)]*?\)', "Missing input validation detected"),
                (r'request\.form\.get\s*\(\s*[^,)]*?\)', "Missing input validation detected"),
            ],
        }
    
    def scan_codebase(self, directory: Optional[str] = None) -> Dict[str, Any]:
        """Scan the codebase for vulnerabilities."""
        if directory is None:
            directory = project_root / "src" / "lcg_password_manager"
        
        print(f"Scanning codebase in {directory} for vulnerabilities...")
        
        # Walk through all Python files in the directory
        for root, _, files in os.walk(directory):
            for file in files:
                if file.endswith(".py"):
                    file_path = Path(root) / file
                    self.scan_file(file_path)
        
        # Calculate risk score
        self.calculate_risk_score()
        
        # Save the results
        self.save_results()
        
        return self.results
    
    def scan_file(self, file_path: Path) -> None:
        """Scan a single file for vulnerabilities."""
        print(f"Scanning {file_path}...")
        
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                content = f.read()
            
            # Check for each vulnerability pattern
            for category, patterns in self.vulnerability_patterns.items():
                for pattern, description in patterns:
                    matches = re.finditer(pattern, content, re.IGNORECASE)
                    for match in matches:
                        line_number = content[:match.start()].count("\n") + 1
                        line_content = content.split("\n")[line_number - 1].strip()
                        
                        vulnerability = {
                            "category": category,
                            "description": description,
                            "file": str(file_path.relative_to(project_root)),
                            "line": line_number,
                            "line_content": line_content,
                            "severity": self.get_severity(category),
                        }
                        
                        self.results["vulnerabilities"].append(vulnerability)
        
        except Exception as e:
            print(f"Error scanning {file_path}: {str(e)}")
    
    def get_severity(self, category: str) -> str:
        """Get the severity level for a vulnerability category."""
        severity_map = {
            "hardcoded_secrets": "Critical",
            "insecure_random": "High",
            "weak_crypto": "Critical",
            "sql_injection": "Critical",
            "command_injection": "Critical",
            "path_traversal": "High",
            "insecure_deserialization": "Critical",
            "debug_code": "Medium",
            "insecure_defaults": "Medium",
            "missing_validation": "Medium",
        }
        
        return severity_map.get(category, "Low")
    
    def calculate_risk_score(self) -> None:
        """Calculate an overall risk score based on the vulnerabilities found."""
        severity_weights = {
            "Critical": 10,
            "High": 7,
            "Medium": 4,
            "Low": 1,
        }
        
        total_weight = 0
        for vuln in self.results["vulnerabilities"]:
            total_weight += severity_weights.get(vuln["severity"], 0)
        
        # Normalize score to 0-100
        max_possible_weight = len(self.results["vulnerabilities"]) * 10
        if max_possible_weight > 0:
            risk_score = int((total_weight / max_possible_weight) * 100)
        else:
            risk_score = 0
        
        self.results["summary"] = {
            "total_vulnerabilities": len(self.results["vulnerabilities"]),
            "risk_score": risk_score,
            "risk_level": "Critical" if risk_score >= 80 else "High" if risk_score >= 60 else "Medium" if risk_score >= 40 else "Low",
            "severity_counts": {
                "Critical": sum(1 for v in self.results["vulnerabilities"] if v["severity"] == "Critical"),
                "High": sum(1 for v in self.results["vulnerabilities"] if v["severity"] == "High"),
                "Medium": sum(1 for v in self.results["vulnerabilities"] if v["severity"] == "Medium"),
                "Low": sum(1 for v in self.results["vulnerabilities"] if v["severity"] == "Low"),
            },
        }
    
    def save_results(self) -> None:
        """Save the scan results to a JSON file."""
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        output_file = self.output_dir / f"vulnerability_scan_{timestamp}.json"
        
        with open(output_file, "w") as f:
            json.dump(self.results, f, indent=2)
        
        print(f"Vulnerability scan results saved to {output_file}")
        
        # Also generate a human-readable report
        self.generate_report(output_file)
    
    def generate_report(self, json_file: Path) -> None:
        """Generate a human-readable report from the JSON results."""
        report_file = json_file.with_suffix(".md")
        
        with open(report_file, "w", encoding="utf-8") as f:
            f.write("# LCG Password Manager - Vulnerability Scan Report\n\n")
            f.write(f"**Date:** {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            
            # Summary section
            f.write("## Summary\n\n")
            summary = self.results.get("summary", {})
            f.write(f"- **Risk Score:** {summary.get('risk_score', 'N/A')}/100\n")
            f.write(f"- **Risk Level:** {summary.get('risk_level', 'N/A')}\n")
            f.write(f"- **Total Vulnerabilities:** {summary.get('total_vulnerabilities', 0)}\n")
            f.write(f"- **Critical Vulnerabilities:** {summary.get('severity_counts', {}).get('Critical', 0)}\n")
            f.write(f"- **High Vulnerabilities:** {summary.get('severity_counts', {}).get('High', 0)}\n")
            f.write(f"- **Medium Vulnerabilities:** {summary.get('severity_counts', {}).get('Medium', 0)}\n")
            f.write(f"- **Low Vulnerabilities:** {summary.get('severity_counts', {}).get('Low', 0)}\n\n")
            
            # Vulnerabilities section
            f.write("## Vulnerabilities\n\n")
            
            # Group vulnerabilities by category
            categories = {}
            for vuln in self.results.get("vulnerabilities", []):
                category = vuln.get("category", "Unknown")
                if category not in categories:
                    categories[category] = []
                categories[category].append(vuln)
            
            # Sort categories by severity
            severity_order = {"Critical": 0, "High": 1, "Medium": 2, "Low": 3}
            sorted_categories = sorted(
                categories.keys(),
                key=lambda c: min(severity_order[v.get("severity", "Low")] for v in categories[c])
            )
            
            for category in sorted_categories:
                vulns = categories[category]
                # Sort vulnerabilities by severity
                vulns.sort(key=lambda v: severity_order[v.get("severity", "Low")])
                
                f.write(f"### {category.replace('_', ' ').title()}\n\n")
                
                for vuln in vulns:
                    # Use text alternatives instead of emoji
                    severity_text = "[CRITICAL]" if vuln.get("severity") == "Critical" else "[HIGH]" if vuln.get("severity") == "High" else "[MEDIUM]" if vuln.get("severity") == "Medium" else "[LOW]"
                    f.write(f"#### {severity_text} {vuln.get('description', 'Unknown vulnerability')}\n\n")
                    f.write(f"**Severity:** {vuln.get('severity', 'Unknown')}\n\n")
                    f.write(f"**File:** `{vuln.get('file', 'Unknown')}`\n\n")
                    f.write(f"**Line:** {vuln.get('line', 'Unknown')}\n\n")
                    f.write("**Code:**\n```python\n")
                    f.write(f"{vuln.get('line_content', '')}\n")
                    f.write("```\n\n")
                
                f.write("\n")
            
            # Recommendations section
            f.write("## Recommendations\n\n")
            
            recommendations = {
                "hardcoded_secrets": "Remove all hardcoded secrets and use environment variables or secure key management systems instead.",
                "insecure_random": "Replace insecure random number generation with cryptographically secure alternatives like `secrets` module.",
                "weak_crypto": "Replace weak cryptographic algorithms with strong alternatives (AES-256, SHA-256, etc.).",
                "sql_injection": "Use parameterized queries or ORM to prevent SQL injection vulnerabilities.",
                "command_injection": "Avoid using shell commands with user input. If necessary, use `shlex.quote()` to escape inputs.",
                "path_traversal": "Validate and sanitize file paths to prevent path traversal attacks.",
                "insecure_deserialization": "Avoid using pickle or yaml.load(). Use json.loads() or custom deserialization with validation.",
                "debug_code": "Remove all debug code that exposes sensitive information.",
                "insecure_defaults": "Use secure default permissions (0o600 for files, 0o700 for directories).",
                "missing_validation": "Implement proper input validation for all user inputs.",
            }
            
            for category in sorted_categories:
                if category in recommendations:
                    f.write(f"- **{category.replace('_', ' ').title()}:** {recommendations[category]}\n")
            
            f.write("\n")
            
            # Action Plan section
            f.write("## Action Plan\n\n")
            
            if summary.get("risk_level") in ["Critical", "High"]:
                f.write("### Immediate Actions (1-3 days)\n\n")
                f.write("1. Address all Critical and High severity vulnerabilities\n")
                f.write("2. Conduct a code review focusing on security\n\n")
                
                f.write("### Short-term Actions (1-2 weeks)\n\n")
                f.write("1. Address Medium severity vulnerabilities\n")
                f.write("2. Implement automated security testing in CI/CD pipeline\n\n")
                
                f.write("### Long-term Actions (1-3 months)\n\n")
                f.write("1. Address Low severity vulnerabilities\n")
                f.write("2. Conduct a comprehensive security audit\n")
                f.write("3. Implement security monitoring and alerting\n")
            elif summary.get("risk_level") == "Medium":
                f.write("### Immediate Actions (1 week)\n\n")
                f.write("1. Address all High severity vulnerabilities\n\n")
                
                f.write("### Short-term Actions (2-4 weeks)\n\n")
                f.write("1. Address Medium severity vulnerabilities\n")
                f.write("2. Implement automated security testing in CI/CD pipeline\n\n")
                
                f.write("### Long-term Actions (2-3 months)\n\n")
                f.write("1. Address Low severity vulnerabilities\n")
                f.write("2. Conduct a comprehensive security audit\n")
                f.write("3. Implement security monitoring and alerting\n")
            else:
                f.write("### Immediate Actions (1-2 weeks)\n\n")
                f.write("1. Address any remaining Medium severity vulnerabilities\n\n")
                
                f.write("### Short-term Actions (1-2 months)\n\n")
                f.write("1. Address Low severity vulnerabilities\n")
                f.write("2. Implement automated security testing in CI/CD pipeline\n\n")
                
                f.write("### Long-term Actions (3-6 months)\n\n")
                f.write("1. Conduct a comprehensive security audit\n")
                f.write("2. Implement security monitoring and alerting\n")
                f.write("3. Consider third-party security assessment\n")
        
        print(f"Vulnerability scan report generated at {report_file}")


def main():
    """Main entry point for the vulnerability scanner."""
    parser = argparse.ArgumentParser(description="Scan LCG Password Manager codebase for vulnerabilities")
    parser.add_argument("--directory", "-d", help="Directory to scan (default: src/lcg_password_manager)")
    parser.add_argument("--output", "-o", help="Output directory for scan reports")
    args = parser.parse_args()
    
    scanner = VulnerabilityScanner(args.output)
    scanner.scan_codebase(args.directory)


if __name__ == "__main__":
    main() 